import system.pyj.minescript as m

Double = JavaClass("java.lang.Double")
Minecraft = JavaClass("net.minecraft.client.Minecraft")
Math = JavaClass("java.lang.Math")
BowItem = JavaClass("net.minecraft.world.item.BowItem")
JString = JavaClass("java.lang.String")

# ------------------------------
# config
# ------------------------------

CANCEL_HOTKEY = 79 # O/o

MAX_TARGET_DISTANCE = 60.0
FULL_DRAW_THRESHOLD = 1.0
DRAW_EPS = 0.01
AIM_CONE_DEGREES = 8.0
REPEAT_SHOTS_WHEN_ACTIVE = True
RELEASE_DELAY_TICKS = 2
POST_RELEASE_HOLD_TICKS = 2
LEAD_EXTRA_TICKS = 4.0
N_AVG_SAMPLES = 4
ARROW_GRAVITY = 0.05
ARROW_DRAG = 0.99
ARROW_SPEED_SCALE = 3.00
VELOCITY_INSTANT_WEIGHT = 0.0
TARGET_Y_BIAS = 0.6
VELOCITY_SMOOTHING = "avg"   # one of: latest, ema, avg
VELOCITY_EMA_ALPHA = 0.6
VELOCITY_SOURCE = "derived"   # one of: derived, server, blend
DERIVED_WINDOW = 4
DERIVED_MAX_SPEED = 1.0
DERIVED_SOURCE_WEIGHT = 0.8

# ------------------------------
# don't touch
# ------------------------------

ACTIVE = True

mc = Minecraft.getInstance()
_velocity_history = {}
_velocity_ema = {}
_pos_history = {}

_current_target = None
_aiming = False
_tick_listener = None
_lock_on_active = False
_hold_ticks_remaining = 0
_hold_yaw = 0.0
_hold_pitch = 0.0

def _get_latency_ticks():
  try:
    conn = mc.getConnection()
    if conn is None:
      return 0.0
    info = conn.getPlayerInfo(mc.player.getUUID())
    if info is None:
      return 0.0
    ms = info.getLatency()
    return float(ms) / 50.0
  except:
    return 0.0

def _vec_to_tuple(v):
    try:
        return (float(v.x), float(v.y), float(v.z))
    except:
        try:
            return (float (v[0]), float(v[1]), float(v[2]))
        except:
            return (0.0, 0.0, 0.0)
        
def _vel_tuple(entity):
    try:
        v = entity.getDeltaMovement()
        return (float(v.x), float(v.y), float(v.z))
    except:
        return (0.0, 0.0, 0.0)

def _entity_key(entity):
    try:
        return entity.getUUID()
    except:
        try:
            return entity.getId()
        except:
            return None

def _push_position_sample(target, pos_tuple, window_N):
    try:
        try:
            key = target.getUUID()
        except:
            key = target.getId()
        if key not in _pos_history:
            _pos_history[key] = []
        hist = _pos_history[key]
        try:
            lvl = mc.level
            tick = lvl.getGameTime() if lvl is not None else 0
        except:
            tick = 0
        try:
            x, y, z = float(pos_tuple[0]), float(pos_tuple[1]), float(pos_tuple[2])
        except:
            try:
                x, y, z = float(pos_tuple.x), float(pos_tuple.y), float(pos_tuple.z)
            except:
                x, y, z = 0.0, 0.0, 0.0
        hist.append((x, y, z, float(tick)))
        if len(hist) > (window_N + 2):
            hist.pop(0)
        return key
    except:
        return None

def _derived_velocity_from_positions(key, window_N):
    hist = _pos_history.get(key, [])
    n = len(hist)
    if n < 2:
        return (0.0, 0.0, 0.0)
    count = int(window_N)
    if count < 1:
        count = 1
    count = min(count, n-1)
    base_idx = n - 1 - count
    def _unpack_pos(entry):
        try:
            if len(entry) >= 4:
                return (float(entry[0]), float(entry[1]), float(entry[2]), float(entry[3]))
        except:
            pass
        try:
            return (float(entry[0]), float(entry[1]), float(entry[2]), None)
        except:
            try:
                return (float(entry.x), float(entry.y), float(entry.z), None)
            except:
                return (0.0, 0.0, 0.0, None)
    p0x, p0y, p0z, t0 = _unpack_pos(hist[base_idx])
    if t0 is None:
        j = base_idx
        while j < n:
            p0x, p0y, p0z, t0 = _unpack_pos(hist[j])
            if t0 is not None:
                base_idx = j
                break
            j += 1
    sx = 0.0
    sy = 0.0
    sz = 0.0
    used = 0
    if t0 is not None:
        for i in range(base_idx + 1, n):
            xi, yi, zi, ti = _unpack_pos(hist[i])
            try:
                dt = float(ti) - float(t0)
            except:
                dt = None
            if dt is None or dt <= 0.0:
                continue
            dx = (xi - p0x) / dt
            dy = (yi - p0y) / dt
            dz = (zi - p0z) / dt
            sx += dx; sy += dy; sz += dz
            used += 1
    else:
        for i in range(base_idx + 1, n):
            dt = i - base_idx
            if dt <= 0:
                continue
            xi, yi, zi, _ = _unpack_pos(hist[i])
            dx = (xi - p0x) / dt
            dy = (yi - p0y) / dt
            dz = (zi - p0z) / dt
            sx += dx; sy += dy; sz += dz
            used += 1
    if used == 0:
        return (0.0, 0.0, 0.0)
    inv = 1.0 / used
    vx = sx * inv; vy = sy * inv; vz = sz * inv
    maxv = float(DERIVED_MAX_SPEED)
    if maxv > 0.0:
        mag2 = vx*vx + vy*vy + vz*vz
        if mag2 > maxv*maxv and mag2 > 1e-12:
            invmag = maxv / Math.sqrt(mag2)
            vx *= invmag; vy *= invmag; vz *= invmag
    return (vx, vy, vz)

def _compute_instant_velocity_for_target(target):
    try:
        mode_src = VELOCITY_SOURCE.lower() if (type(VELOCITY_SOURCE) == JString or type(VELOCITY_SOURCE) == str) else "derived"
    except:
        mode_src = "derived"
    key_pos = _entity_key(target)
    if mode_src == "derived":
        return _derived_velocity_from_positions(key_pos, DERIVED_WINDOW)
    elif mode_src == "server":
        return _vel_tuple(target)
    else:
        inst_d = _derived_velocity_from_positions(key_pos, DERIVED_WINDOW)
        inst_s = _vel_tuple(target)
        dw = float(DERIVED_SOURCE_WEIGHT)
        return (inst_d[0]*dw + inst_s[0]*(1.0-dw),
                inst_d[1]*dw + inst_s[1]*(1.0-dw),
                inst_d[2]*dw + inst_s[2]*(1.0-dw))

def _update_target_histories(target):
    try:
        tp = _pos_tuple(target)
        _push_position_sample(target, tp, DERIVED_WINDOW)
        inst = _compute_instant_velocity_for_target(target)
        _smoothed_velocity_for(target, N_AVG_SAMPLES, inst_override=inst)
        return True
    except:
        return False

def _view_vec_from_rot(ent):
    try:
        yaw_deg = ent.getYRot()
        pitch_deg = ent.getXRot()
        yr = Math.toRadians(yaw_deg)
        pr = Math.toRadians(pitch_deg)
        cp = Math.cos(pr)
        x = -Math.sin(yr) * cp
        y = -Math.sin(pr)
        z = Math.cos(yr) * cp
        return (float(x), float(y), float(z))
    except:
        return (0.0, 0.0, 1.0)

def _bow_speed(player):
    stack = player.getMainHandItem()
    if stack is None or stack.isEmpty():
        return None

    item = stack.getItem()

    if BowItem != type(item):
        return None

    try:
        if not player.isUsingItem():
            return 0.0
    except:
        pass

    use_ticks = item.getUseDuration(stack, player) - player.getUseItemRemainingTicks()

    f = float(use_ticks) / 20.0
    f = (f * f + f * 2.0) / 3.0
    if f > 1.0:
        f = 1.0

    return f * ARROW_SPEED_SCALE

def _avg_velocity_for(target, window_N=10):
    try:
        try:
            key = target.getUUID()
        except:
            key = target.getId()

        if key not in _velocity_history:
            _velocity_history[key] = []

        v_now = target.getDeltaMovement()
        vx, vy, vz = _vec_to_tuple(v_now)
        hist = _velocity_history[key]
        hist.append((vx, vy, vz))
        if len(hist) > window_N:
            hist.pop(0)

        sx = 0.0
        sy = 0.0
        sz = 0.0
        for v in hist:
            try:
                sx += v[0]; sy += v[1]; sz += v[2]
            except:
                sx += getattr(v, 'x', 0.0)
                sy += getattr(v, 'y', 0.0)
                sz += getattr(v, 'z', 0.0)
        inv = 1.0 / len(hist)
        return (sx * inv, sy * inv, sz * inv)
    except Exception as e:
        return (0.0, 0.0, 0.0)

def _push_velocity_sample(target, inst_tuple, window_N):
    try:
        try:
            key = target.getUUID()
        except:
            key = target.getId()
        if key not in _velocity_history:
            _velocity_history[key] = []
        hist = _velocity_history[key]
        hist.append(inst_tuple)
        if len(hist) > window_N:
            hist.pop(0)
        return key
    except:
        return None

def _avg_from_history(key):
    hist = _velocity_history.get(key, [])
    if not hist:
        return (0.0, 0.0, 0.0)
    sx = 0.0
    sy = 0.0
    sz = 0.0
    n = 0
    for v in hist:
        try:
            m.echo(v)
            sx += v[0]
            sy += v[1]
            sz += v[2]
            n += 1
        except:
            pass
    if n == 0:
        return (0.0, 0.0, 0.0)
    inv = 1.0 / n
    return (sx*inv, sy*inv, sz*inv)

def _smoothed_velocity_for(target, window_N, inst_override=None):
    inst = inst_override if inst_override is not None else _vel_tuple(target)
    key = _push_velocity_sample(target, inst, window_N)
    try:
        mode = VELOCITY_SMOOTHING.lower() if (type(VELOCITY_SMOOTHING) == JString or type(VELOCITY_SMOOTHING) == str) else "avg"
    except:
        mode = "avg"
    if mode == "latest":
        return inst
    if mode == "ema":
        alpha = float(VELOCITY_EMA_ALPHA)
        if key is None:
            return inst
        prev = _velocity_ema.get(key, inst)
        vx = alpha*inst[0] + (1.0-alpha)*prev[0]
        vy = alpha*inst[1] + (1.0-alpha)*prev[1]
        vz = alpha*inst[2] + (1.0-alpha)*prev[2]
        _velocity_ema[key] = (vx, vy, vz)
        return _velocity_ema[key]
    if key is None:
        return inst
    return _avg_from_history(key)

def _pos_tuple(entity):
    try:
        p = entity.getEyePosition()
    except:
        try:
            p = entity.getBoundingBox().getCenter()
        except:
            p = entity.position()
    return (float(p.x), float(p.y), float(p.z))

def _solve_ballistic_dir(shooter_pos, target_pos, target_vel, arrow_speed):
    g = ARROW_GRAVITY
    sx, sy, sz = shooter_pos
    tx, ty, tz = target_pos
    vx, vy, vz = target_vel

    dx0 = tx - sx
    dy0 = ty - sy
    dz0 = tz - sz
    dist0 = Math.sqrt(dx0*dx0 + dy0*dy0 + dz0*dz0)
    if arrow_speed <= 0.01:
        return None
    t_min = 1.0
    t_guess = dist0 / max(arrow_speed, 0.01)
    t_max = max(12.0, t_guess * 3.5)

    def speed_diff(t):
        dx = (tx + vx*t) - sx
        dy = (ty + vy*t) - sy
        dz = (tz + vz*t) - sz

        eta = ARROW_DRAG
        denom = (1.0 - eta)
        try:
            S = (1.0 - Math.pow(eta, t)) / denom
        except:
            S = t
        if S < 1e-6:
            S = t

        v0x = dx / S
        v0z = dz / S

        try:
            gterm = g * (t - S) / denom
        except:
            gterm = g * t
        v0y = (dy + gterm) / S

        s = Math.sqrt(v0x*v0x + v0y*v0y + v0z*v0z)
        return (s - arrow_speed, (v0x, v0y, v0z), s)

    N = 28
    best_abs = 1e18
    best_v0 = None
    best_s = None
    prev_f = None
    prev_t = None
    a = None
    b = None
    fa = None
    fb = None
    for i in range(N):
        t = t_min + (t_max - t_min) * (i / (N - 1))
        f, v0, s = speed_diff(t)
        af = abs(f)
        if af < best_abs:
            best_abs = af
            best_v0 = v0
            best_s = s
        if prev_f is not None and f * prev_f <= 0.0:
            a, b = prev_t, t
            fa, fb = prev_f, f
            break
        prev_f = f
        prev_t = t

    if a is not None:
        for _ in range(22):
            mid = 0.5 * (a + b)
            f, v0, s = speed_diff(mid)
            if abs(f) < best_abs:
                best_abs = abs(f)
                best_v0 = v0
                best_s = s
            if f * fa <= 0.0:
                b, fb = mid, f
            else:
                a, fa = mid, f

    if best_v0 is None or best_s is None or best_s <= 1e-9:
        return None
    v0x, v0y, v0z = best_v0
    inv = 1.0 / best_s
    return (v0x*inv, v0y*inv, v0z*inv)

def lock_on(player, target):
    N_AVG = N_AVG_SAMPLES

    arrow_speed = _bow_speed(player)
    if arrow_speed is None:
        return

    try:
        shooter_pos = _pos_tuple(player)
        tp = _pos_tuple(target)
        target_pos = (tp[0], tp[1] + TARGET_Y_BIAS, tp[2])
        inst = _compute_instant_velocity_for_target(target)
        try:
            mode = VELOCITY_SMOOTHING.lower() if (type(VELOCITY_SMOOTHING) == JString or type(VELOCITY_SMOOTHING) == str) else "avg"
        except:
            mode = "avg"
        key = _entity_key(target)
        if mode == "latest":
            vel_smooth = inst
        elif mode == "ema":
            vel_smooth = _velocity_ema.get(key, inst)
        else:
            vel_smooth = _avg_from_history(key)
        w = float(VELOCITY_INSTANT_WEIGHT)
        iw = 1.0 - w
        target_vel = (inst[0]*w + vel_smooth[0]*iw,
                      inst[1]*w + vel_smooth[1]*iw,
                      inst[2]*w + vel_smooth[2]*iw)
    except Exception as e:
        try:
            m.echo("[aim] pos/vel fetch failed: " + str(e))
        except:
            pass
        return

    try:
        vx, vy, vz = target_vel
        try:
            try:
                key = target.getUUID()
            except:
                key = target.getId()
            hist = _velocity_history.get(key, [])
            if hist is not None and len(hist) >= 2:
                ax = hist[-1][0] - hist[-2][0]
                ay = hist[-1][1] - hist[-2][1]
                az = hist[-1][2] - hist[-2][2]
            else:
                ax = 0.0
                ay = 0.0
                az = 0.0
        except:
            ax = ay = az = 0.0
        tlead = float(RELEASE_DELAY_TICKS) + _get_latency_ticks() + float(LEAD_EXTRA_TICKS)
        lead_pos = (target_pos[0] + vx * tlead + 0.5 * ax * tlead * tlead,
                    target_pos[1] + vy * tlead + 0.5 * ay * tlead * tlead,
                    target_pos[2] + vz * tlead + 0.5 * az * tlead * tlead)
        direction = _solve_ballistic_dir(shooter_pos, lead_pos, target_vel, arrow_speed)
    except Exception as e:
        try:
            m.echo("[aim] solver failed: " + str(e))
        except:
            pass
        direction = None

    if direction is None:
        dx = target_pos[0] - shooter_pos[0]
        dy = target_pos[1] - shooter_pos[1]
        dz = target_pos[2] - shooter_pos[2]
        lsq = dx*dx + dy*dy + dz*dz
        if lsq > 1e-12:
            invl = 1.0 / Math.sqrt(lsq)
            direction = (dx*invl, dy*invl, dz*invl)
        else:
            direction = _view_vec_from_rot(player)

    try:
        dx, dy, dz = float(direction[0]), float(direction[1]), float(direction[2])
    except Exception as e:
        try:
            m.echo("[aim] bad direction: " + str(direction))
        except:
            pass
        return

    yaw   = Math.toDegrees(Math.atan2(-dx, dz))
    vy = dy
    if vy > 1.0:
        vy = 1.0
    elif vy < -1.0:
        vy = -1.0
    pitch = Math.toDegrees(-Math.asin(vy))
    return (float(yaw), float(pitch))

def _fire_with_cleanup(spd):
    global _aiming, _current_target, _lock_on_active
    try:
      m.player_press_use(False)
    except:
      pass
    if REPEAT_SHOTS_WHEN_ACTIVE:
      try:
        m.set_timeout(lambda: m.player_press_use(True), 75)
      except:
        pass
    else:
      _aiming = False
      _current_target = None
      _lock_on_active = False
      try:
        m.echo("[tick] shot fired at spd=" + str(round(spd,3)) + "; Lock: OFF")
      except:
        pass

def _get_crosshair_entity():
    data = m.player_get_targeted_entity(MAX_TARGET_DISTANCE, False)
    if data is None:
        return None
    try:
        eid = data.id
    except:
        eid = data["id"]
    level = mc.level
    if level is None:
        return None
    return level.getEntity(eid)

def _is_bad_target(entity):
    if entity is None:
        return True
    try:
        if entity.isRemoved():
            return True
    except:
        pass
    try:
        dist = mc.player.distanceTo(entity)
        if dist > MAX_TARGET_DISTANCE:
            return True
    except:
        pass
    return False

def _find_best_entity_in_cone():
    eds = m.entities(False, None, None, None, None, None, None, MAX_TARGET_DISTANCE, "nearest", 64)
    if eds is None:
        return None

    ep = mc.player.getEyePosition()
    eye = (float(ep.x), float(ep.y), float(ep.z))
    try:
        vv = mc.player.getViewVector(1.0).normalize()
        view = (float(vv.x), float(vv.y), float(vv.z))
    except:
        view = _view_vec_from_rot(mc.player)
    cos_thresh = Math.cos(Math.toRadians(AIM_CONE_DEGREES))

    best = None
    best_dot = -2.0
    best_dist = 1e18

    level = mc.level
    if level is None:
        return None

    count = 0
    for e in eds:
        try:
            count += 1
            try:
                if e.local:
                    continue
            except:
                pass

            ent = level.getEntity(e.id)
            if ent is None:
                continue

            try:
                if e.health is None:
                    pass
            except:
                pass

            try:
                tp = ent.getEyePosition()
            except:
                try:
                    tp = ent.getBoundingBox().getCenter()
                except:
                    continue
            tpos = (float(tp.x), float(tp.y), float(tp.z))

            dx = tpos[0] - eye[0]
            dy = tpos[1] - eye[1]
            dz = tpos[2] - eye[2]
            dist = Math.sqrt(dx*dx + dy*dy + dz*dz)
            if dist <= 0.0 or dist > MAX_TARGET_DISTANCE:
                continue

            invl = 1.0 / dist
            dir_to = (dx*invl, dy*invl, dz*invl)
            dot = dir_to[0]*view[0] + dir_to[1]*view[1] + dir_to[2]*view[2]

            if dot < cos_thresh:
                continue

            if dot > best_dot + 1e-9 or (abs(dot - best_dot) <= 1e-9 and dist < best_dist):
                best = ent
                best_dot = dot
                best_dist = dist
        except:
            pass

    return best

def _acquire_target():
    t = _get_crosshair_entity()
    if t is not None and not _is_bad_target(t):
        return t
    c = _find_best_entity_in_cone()
    return c

def _begin_lock_and_fire():
    global _current_target, _aiming, _lock_on_active
    if not ACTIVE:
        return
    speed = _bow_speed(mc.player)
    if speed is None:
        m.echo("Equip a bow in main hand to lock-on.")
        return

    target = _acquire_target()
    if target is None:
        m.echo("No target in view cone.")
        return

    _current_target = target
    try:
      try:
        key = target.getUUID()
      except:
        key = target.getId()
      _velocity_history[key] = []
      try:
        _velocity_ema.pop(key, None)
      except:
        pass
      _pos_history[key] = []
    except:
      pass
    _lock_on_active = True
    _aiming = True
    m.player_press_use(True)

def _toggle_lock():
    global _lock_on_active
    if _lock_on_active:
        _lock_on_active = False
        _cancel_lock()
        m.echo("Lock: OFF")
    else:
        _begin_lock_and_fire()
        if _lock_on_active:
            m.echo("Lock: ON")

def _cancel_lock():
    global _current_target, _aiming
    _aiming = False
    _current_target = None
    m.player_press_use(False)

def _on_key(event):
    if event.action != 1:
        return
    if event.key == CANCEL_HOTKEY or event.key == 'o' or event.key == 'O':
        _cancel_lock()
        m.echo("Lock: OFF")

def _on_mouse(event):
    try:
        if event.action == 1 and event.button == 0:
            _toggle_lock()
    except:
        pass

def _on_tick(event):
    global _current_target, _aiming, _lock_on_active, _hold_ticks_remaining, _hold_yaw, _hold_pitch
    if _hold_ticks_remaining > 0:
        try:
            m.player_set_orientation(_hold_yaw, _hold_pitch)
        except:
            pass
        _hold_ticks_remaining -= 1

    if not _lock_on_active:
        return

    if _current_target is None or _is_bad_target(_current_target):
        _cancel_lock()
        _lock_on_active = False
        return

    try:
        _update_target_histories(_current_target)
    except:
        pass

    if _bow_speed(mc.player) is None:
        m.echo("[tick] cancel: bow missing/not in main hand")
        _cancel_lock()
        return

    try:
        spd = _bow_speed(mc.player)
        if spd is not None and (spd / ARROW_SPEED_SCALE) >= (FULL_DRAW_THRESHOLD - DRAW_EPS):
            res = lock_on(mc.player, _current_target)
            if res is not None:
                try:
                    yaw, pitch = res
                    m.player_set_orientation(yaw, pitch)
                    _hold_yaw = float(yaw)
                    _hold_pitch = float(pitch)
                    _hold_ticks_remaining = POST_RELEASE_HOLD_TICKS
                except:
                    pass
            try:
                m.set_timeout(_fire_with_cleanup, 0, spd)
            except:
                _fire_with_cleanup(spd)
    except Exception as e:
        try:
            m.echo("[tick] lock_on exception: " + str(e))
        except:
            pass
        return

if _tick_listener is None:
    m.add_event_listener("key", _on_key)
    m.add_event_listener("mouse", _on_mouse)
    _tick_listener = m.add_event_listener("tick", _on_tick)
    try:
        ck = chr(CANCEL_HOTKEY)
    except:
        ck = 'O'
    m.echo(f"[Bow Aimbot] Lock: Mouse1  Cancel: {ck}")
    try:
        jobs = m.job_info()
        self_job = None
        for j in jobs:
            if j.self:
                self_job = j
                break
        if self_job is not None:
            for arg in self_job.command:
                try:
                    if arg.startswith("--vel-mode="):
                        VELOCITY_SMOOTHING = arg.split("=",1)[1]
                    elif arg.startswith("--vel-alpha="):
                        VELOCITY_EMA_ALPHA = float(arg.split("=",1)[1])
                    elif arg.startswith("--n-avg="):
                        N_AVG_SAMPLES = int(float(arg.split("=",1)[1]))
                    elif arg.startswith("--vel-instant="):
                        VELOCITY_INSTANT_WEIGHT = float(arg.split("=",1)[1])
                    elif arg.startswith("--vel-source="):
                        VELOCITY_SOURCE = arg.split("=",1)[1]
                    elif arg.startswith("--derived-window="):
                        DERIVED_WINDOW = int(float(arg.split("=",1)[1]))
                    elif arg.startswith("--derived-max="):
                        DERIVED_MAX_SPEED = float(arg.split("=",1)[1])
                    elif arg.startswith("--derived-weight="):
                        DERIVED_SOURCE_WEIGHT = float(arg.split("=",1)[1])
                except:
                    pass
    except:
        pass
